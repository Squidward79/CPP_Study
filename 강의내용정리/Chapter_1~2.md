/// 강의는 순서대로 보지만 굳이 불필요한 내용은 스킵하였음
/// 몰랐거나 잊어버린 내용 위주로 정리함

# 목차
[1.C++기초](#-1.-C++-기초)

[2.변수와-기본적인-자료형](#-2.-변수와-기본적인-자료형)


# 1. C++ 기초

## 헤더파일 만들기
- 비슷한 함수들을 묶어서 하나의 파일에 넣음
- 헤더로 빼서 선언한다. cpp에는 정의를 한다
- 내부에 있는 include는 ""를 쓴다. 컴퓨터에 설치된 include는 <>

- 헤더부터 설계하는게 일반적

- 헤더가드(#pragma one)는 헤더를 include 해올때 중복될 경우에 한번만 가져오도록 제한해주는 역할을 한다.
    - 헤더 내에 선언과 정의를 함께 할 경우 생기는 문제를 방지해줌
    - namespace를 헤더에서 쓸 경우, 함수 내에 선언하는게 문제를 만들지 않는다.

## 전처리기 관련 사항
- #include 가장 흔히 사용
- #define MY_NUMBER 9 : 매크로라고도 부르고, 대문자로 쓰는게 일반적. 전처리단계에서 해당 부분을 치환해버린다
  - **현업에선 #define으로 크기 등을 결정하거나 하는 코드는 잘 안씀**
  - 과거엔 Function의 퍼포먼스가 매크로에 비해 떨어진다 생각하여 많이 썼으나 지금은 하드웨어 퍼포먼스가 좋아서 잘 안쓴다.
  - 매크로를 쓰면 디버깅이 힘들고, 전처리기이기 때문에 코드 전체에 영향을 준다.
  - 보통 많이쓰는 MAX는 algorithm.h 안에 std::max() 로 쓸 수 있다.

- #ifdef / #ifndef  ~~ #endif: #define으로 정의되어 있을때,아닐때 처리하는 부분. 보통 그래픽카드 사양이나 OS에 따라 다른 처리할 때 사용한다.
  - #define이 교체를 해버리지만, 전처리기 라인 안에서는 교체하지 않는다.
  - #define의 효과는 하나의 파일 안에서만 적용된다.

# 2. 변수와 기본적인 자료형
  ## C++의 타입들
> c++ 표준에서는 타입의 최소 크기만 지정하고 있기 때문에 플랫폼,컴파일러마다 조금씩 구현된 크기는 조금씩 다를 수 있다. 

  - char16_t, char32_t는 이모티콘 등의 더 다양한 문자를 표현하기 위해 존재. 16,32 bits를 의미한다.
  - wchar_t는 winAPI,QT에서 주로 사용한다. 문자 저장 방식이 아예 다르기 때문에 문제가 발생할 수 도 있다.
  - string은 기본 데이터타입이 아니다. std에 포함된 자료형이다.
  - char는 캐릭터타입이기도 하지만 integer 타입이기도 하다. 내부적으로는 정수로 바뀌어 저장되기 때문

  - signed 는 -,+ 전부 가능. unsigned 는 +만 가능. 연산의 방식이 약간 다르고 때에 따라 unsigned가 빠르다.
  - short같은 것들은 사실 *signed*short *int* 가 숨겨져 있는 것이다.
  
  - floating-point types 는 실수부와 지수부로 구분하여 저장하기 때문에, 조금 처리하는 방법이 다르다.
  - float은 뒤에 f를 붙이고, double은 뒤에 f를 안붙인다.
  -  타입에 auto를 줘버리면 컴파일러가 알아서 타입을 지정한다.

 - __변수를 선언하는 방법들__
    - 1. int a = 123; // copy initialization. 일반적인 선언
    - 1. float a(123); //direct initialization. 
    - 2. bool b{123}; //uniform initialization. 
      - uniform쪽이 타입 안맞으면 warning이 아니라 error가 떠서 좀 더 엄격하다. 
      - 최근엔 이쪽을 권장한다.
</br>

  > 변수의 선언은 코드 최상단이 아닌 사용하기 직전에 선언하고 사용하는 것이 최근 경향이다. (리팩토링에 좋음)

## Integer 
  영역|타입|최소크기|기타
  --|--|--|--|
  문자|char|1byte|
  정수|Short|2byte|
  | | int|2byte|대부분 4byte|
  || long|4byte|
  || long long | 8byte| c99/c++11 type|

  - integer의 데이터 구조 
    - 32비트 중 가장 앞의 1비트는 부호를 표현

- **표현 범위를 넘어가서 overflow가 나면, 가장 작은(큰) 수로 돌아가 버린다.**
    - 근데 컴파일러에서는 에러나 워닝을 띄우지 않는다.

## 고정 너비 정수 (Fixed-width integer)
- c++11에서 정의된 데이터 타입으로, 어떤 플랫폼에서도 항상 같은 크기로  사용할 수 있는 데이터 타입으로 코딩의 불확실성을 줄인다.
- iostream 혹은 cstdint 를 include 해야 사용할 수 있다.
- EX) int8_t(8bits형 데이터 타입), int_fast8_t(8bits형 데이터 타입중 가장 빠른 것)
- 즉, 플랫폼 관계 없이 일정한 크기를 지정하면 컴파일러마다 해당 크기에 맞는 데이터 타입을 맞추는 느낌. 멀티플랫폼 프로그래밍에 자주 쓰인다.

 ## Void (무치형)
 - void는 메모리를 차지하지 않기 때문에, 일반적으로는 선언할 수 없다.
 - 포인터를 사용해야만 void형 변수를 선언할 수 있다.
    + 주소를 표현하는 데이터의 양은 동일하다.

## Float
- float형은 사용할 때 f를 붙인다.
- float형은 최소크기가 4byte
- EX) 3.14 = 31.4e-1 // e-1 은 10^-1을 의미. e10이라면10^10이다. 자리수 클 때 유용
- float는 수 표현에서 생각보다 정밀도가 높지 않다...
- 부동소수점 연산은 아주 정확한 수로 계산하기 쉽지 않다. 2진수 표현이기 때문

## Bool
- 출력시킬 때 std::boolalpha / noboolalpha; 를 앞에 해주면 0,1 <-> true,false로 출력된다.
- not operator( ! )를 붙이면 반대로 바뀜. 근데 디버깅할 때 찾기 힘들어서 많이 안쓰는게 좋다.
- if 조건은 0 아니면 전부 true이다..!

## Char
- c 스타일로 캐스팅
```c
cout << (char)65 << endl;
cout << (int)'A' << endl;
``` 
- c++ 스타일로 캐스팅
```c++
cout << char(65) << endl;
cout << int('A') << endl;
//direct 초기화로 새로 만들어준다는 느낌
```
- static_cast를 이용한 캐스팅
```c++
cout << static_cast<char>(65) <<endl;
cout << static_cast<int>('A') << endl;
//기본타입간 변환 때 컴파일러가 체크를 한번 더 하는 캐스팅
//변수를 캐스팅할 경우, 해당 변수의 값 자체는 변하지 않는다.
```

- char에 1byte이상 입력하면, input buffer에 남아있다.
  - cin 으로 받아왔는데 buffer에 남아있는게 있다면 다시 cin 호출 때 그냥 버퍼에 있는게 넘어와버린다.

- '+' \n 과 endl의 차이
  - \n은 그냥 개행,  endl은 버퍼의 모든 것을 출력한 후 개행
  - flush 는 개행없이 버퍼의 모든 것을 출력

- \를 이용한 escape sequance
  - \ " : 텍스트 안에서 " 를 출력한다.
  - \a : 시스템 알림음을 낸다.

## literal Constants
- literal 은 메모리공간에 변수가 잡히면 그 값을 바꿀 수 있는 상수
- 매직넘버(하드코딩으로 숫자가 직접 코드에 들어있는 것)를 코드에 남겨두는 것은 별로 좋지 않다.

- 10진수(Decimal) : 0 1 2 3 4 5 6 7 8 9 10 ...
- 8진수(Octal)    : 0 1 2 3 4 5 6 7 10 11 12 13 ...
- 16진수(Hexa)    : 0 1 2 3 4 5 6 7 8 9 A B C D E F 10 ...

- 8진수를 표현할 땐 앞에 0을 붙인다. EX) `int x = 012;` = 10
- 16진수를 표현할 땐 앞에 0x를 붙인다. EX) `int x = 0xF;` = 15
  - 오픈소스 등에서 8진수나 16진수 많이 사용된다.
  - 2진수보단 16진수가 표기에 편하기 때문

- c++14 부터는 binary literal이 가능해짐 
  - 0b를 붙이면 2진수도 사용가능하다. EX) `int x = 0b1011'1000;` , '는 컴파일 시 무시됨

## Symbolic Constants
- 보통 데이터 타입 앞에 const를 붙여 상수화 한다.
- const 붙일 땐 항상 초기화가 같이 이루어져야 한다.

- #### 자주쓰는 곳 1. 함수의 파라미터
  - 파라미터를 const로 막아버려서 입력값이 변하지 않게 한다.
  - 굳이 파라미터의 값을 바꾸어야 할 땐 변수를 따로 선언하는게 좋다.
  - 오픈소스들에서는 const int& 처럼 레퍼런스로 받고 const해주는게 대부분
  ```c++
  void printNumber(const int& my_number)
  {
    int n = my_number;
    n++;
    cout << n << endl;
  }
  ```

- 상수의 결정 시기에 따른 차이
  - `const int my_const(123);` 처럼 컴파일타임에 결정되는 상수를 컴파일 타임 상수라고 부른다.
  - `cin>>number;     const int special_number(number);` 처럼 런타임에서 결정되는 상수도 존재한다.
  - 일반적으로 이 둘은 문법 상 구분하기 어렵기 때문에 c++11에서 **constexpr**이 추가되었다.
  -  constexpr을 붙이면 *컴파일타임*에 결정되는 상수라는 것을 명시해준다.

- c++에서는 매직넘버, 매크로 대신 const 붙인 상수를 사용하는 것이 바람직

- #### 자주쓰는 곳 2. 헤더에 const를 모아두기
  - 헤더에 const를 모아둘 namespace를 정의한다.
  - const, constexpr을 이용해 const 상수를 정의한다.
  - 다른 cpp에서 include 후 활용한다.
