# 3장 연산자

## 목차

[3.1. sizeof](#1)

[3.2. 연산자](#2)

[3.3. 조건부 연산자](#3)

[3.4. 관계 연산자](#4)

[3.5. 논리 연산자](#5)

[3.6. 이진수](#6)

[3.7. 비트단위 연산자](#7)




********
<div id ="1"></div>

## 연산자 sizeof
- 변수,타입의 크기를 반환. byte단위로 반환
- **sizeof는 연산자이다!**
- 변수에 쓸 때는 ()가 없어도 작동한다.


********
<div id ="2"></div>

## , comma 연산자

- ,로 연결된 내용을 전부 처리한 뒤에 마지막 부분을 대입한다. 각 항의 계산이 먼저임.
- for문에서 꽤 자주 사용된다고 함.

``` c++
    int z = (++x,++y); 
    // x의 증가처리, y의 증가처리를 한 후 y를 z에 대입

    int z = a,b; 
    // 이렇게 쓰면 ,보다 =가 늦어서 그냥 a가 z에 들어가버린다. 
    // ()로 묶어주자.
  ```
  
******** 
<div id ="3"></div>

## 조건부 연산자

- conditional operator = arithmetric if = 삼항연산자
- 삼항연산자인건 c c++에 항이 3개인 연산자가 조건부연산자 뿐이기 때문이다.
- const를 걸 때 유용하다. const 선언할 때 조건부연산을 걸 수 있다.
- 대입할 타입은 맞추는게 좋다.


********
<div id ="4"></div>

## 관계 연산자

- < > = 같은 것들
- 부동소수점 비교시에 문제가 생길 수 있다.
  - 부동소수점은 비교할 때, 작은 어떤 수 epsilon을 설정하고 두 수의 차이값의 절대값이 epsilon보다 작으면 아주 근소한 차이이므로 같은 수 라고 판단하게 하는 것이 좋다.
  
********
<div id ="5"></div>

## 논리 연산자

-  일반적으로 if에서 많이 사용하는 논리연산자
-  && , || , ==, != 등등 
-  short circuit evaluation -> if문에서 여러개의 논리연산을 사용할 때 주의
  
  ``` c++
    int a = 2;
    int b = 2;

    if(x == 2 && y++ == 2)
    {
        //이때 y가 3이 나온다.
    }

    //&&연산자는 false를 만나는 순간 먼저 끝나기 때문에,
    if(x == 1 && y++ == 2)
    {
        //이 경우 x == 1 에서 if문을 바로 빠져나와,
        //y++가 실행되지 않고 바로 빠져나온다.
        //즉 y는 2가 나온다.

        //!!! 코드가 짧아질 수 있지만 리딩에 주의가 필요한 케이스!
    }

    cout << y << endl;
  ```

  **- 주의할점: && 연산자가 || 연산자보다 우선순위가 높다!!**
  - 괄호로 싸서 확실하게 우선순위를 명시하는 편이 좋다. 
  ``` c++
    bool v1 = true;
    bool v2 = false;
    bool v3 = false;

    bool r1 = v1 || v2 && v3;
    bool r2 = (v1 || v2) && v3;
    bool r3 = v1 || (v2 && v3);

    cout << r1 << endl;
    cout << r2 << endl;
    cout << r3 << endl;

    //결과 
    // 1 0 1 

  ```
********
<div id ="6"></div>

## 이진수
- 2진수에서 10진수로 변환하기 -> 자릿수를 다 곱해서 더한다
- 10진수를 2진수로 변환하기 -> 계속 2로 나눈다. 나머지는 0, 1인데, 몫이 0이 될때까지 2로 나눈 후 역으로 나머지를 적어내면 2진수가 됨
 
  ********
<div id ="7"></div>

## 비트단위 연산자 
 - 낭비되는 메모리를 최소화 하기 위해서 비트 단위로 연산할 수 있게 만든 연산자
 - 비트단위로 연산하면 계산속도가 빠르다
 - 비트연산을 할때는 대부분 unsigned를 사용한다
  
  ### **<<** left shift 
     비트를 왼쪽으로 한칸씩 밀어준다. 숫자가 2배씩 커진다
     2배씩 커지는 연산을 할때 *말고 <<를 쓰는게 훨씬 퍼포먼스가 좋다

  ### **>>** right shift    
     비트를 오른쪽으로 한칸씩 밀어준다. 숫자가 2배씩 작아진다
     2로 나누는 연산을 할때 *나 /말고 >>를 쓰는게 훨씬 퍼포먼스가 좋다

  ### **~**  not
     0과 1을 뒤바꾼다. 10진수에서의 규칙성은 특별히 없다

  ### **&**  and
     각 비트별로 and연산을 한 결과를 2진수로 나타낸다
     각 자리의 두 비트의 값이 같으면 1, 다르면 0이다 

  ### **|**  or
     각 비트별로 or연산을 한 결과를 2진수로 나타낸다
     각 자리의 두 비트중 하나라도 1이면 1, 둘 다 0이면 0이다

  ### **^**  xor
     각 비트별로 xor연산을 한 결과를 2진수로 나타낸다
     각 자리의 두 비트의 값이 서로 다르면 1, 같으면 0이다 


  - cout cin에서의 << >> 과는 다른 의미이다
  - 여기서는 연산자 오버로딩으로 다르게 사용되고 있다
   
  <br>

  - and or xor은 비트마스크 비트플래그 처리에 유용하게 쓰인다
  - and or xor의 결과값은 10진수로 나온다 

  <br>

  - 0b를 앞에 붙이면 2진수로 바로 표현이 가능하다 
    - ex) 0b0110 => 5

******

### bitset 라이브러리 
- bitset을 include하여 사용한다
- `std::bitset<보여줄 비트 수>(정수)` 형태로 사용
- 10진수를 2진수로 바꾸어 보여준다

