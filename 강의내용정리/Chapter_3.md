# 3장 연산자

## 목차

[3.1. sizeof](#1)

[3.2. 연산자](#2)

[3.3. 조건부 연산자](#3)

[3.4. 관계 연산자](#4)

[3.5. 논리 연산자](#5)

[3.6. 이진수](#6)

[3.7. 비트단위 연산자](#7)

[3.8. 비트플래그, 비트마스크](#8)





********
<div id ="1"></div>

## 연산자 sizeof
- 변수,타입의 크기를 반환. byte단위로 반환
- **sizeof는 연산자이다!**
- 변수에 쓸 때는 ()가 없어도 작동한다.


********
<div id ="2"></div>

## , comma 연산자

- ,로 연결된 내용을 전부 처리한 뒤에 마지막 부분을 대입한다. 각 항의 계산이 먼저임.
- for문에서 꽤 자주 사용된다고 함.

``` c++
    int z = (++x,++y); 
    // x의 증가처리, y의 증가처리를 한 후 y를 z에 대입

    int z = a,b; 
    // 이렇게 쓰면 ,보다 =가 늦어서 그냥 a가 z에 들어가버린다. 
    // ()로 묶어주자.
  ```
  
******** 
<div id ="3"></div>

## 조건부 연산자

- conditional operator = arithmetric if = 삼항연산자
- 삼항연산자인건 c c++에 항이 3개인 연산자가 조건부연산자 뿐이기 때문이다.
- const를 걸 때 유용하다. const 선언할 때 조건부연산을 걸 수 있다.
- 대입할 타입은 맞추는게 좋다.


********
<div id ="4"></div>

## 관계 연산자

- < > = 같은 것들
- 부동소수점 비교시에 문제가 생길 수 있다.
  - 부동소수점은 비교할 때, 작은 어떤 수 epsilon을 설정하고 두 수의 차이값의 절대값이 epsilon보다 작으면 아주 근소한 차이이므로 같은 수 라고 판단하게 하는 것이 좋다.
  
********
<div id ="5"></div>

## 논리 연산자

-  일반적으로 if에서 많이 사용하는 논리연산자
-  && , || , ==, != 등등 
-  short circuit evaluation -> if문에서 여러개의 논리연산을 사용할 때 주의
  
  ``` c++
    int a = 2;
    int b = 2;

    if(x == 2 && y++ == 2)
    {
        //이때 y가 3이 나온다.
    }

    //&&연산자는 false를 만나는 순간 먼저 끝나기 때문에,
    if(x == 1 && y++ == 2)
    {
        //이 경우 x == 1 에서 if문을 바로 빠져나와,
        //y++가 실행되지 않고 바로 빠져나온다.
        //즉 y는 2가 나온다.

        //!!! 코드가 짧아질 수 있지만 리딩에 주의가 필요한 케이스!
    }

    cout << y << endl;
  ```

  **- 주의할점: && 연산자가 || 연산자보다 우선순위가 높다!!**
  - 괄호로 싸서 확실하게 우선순위를 명시하는 편이 좋다. 
  ``` c++
    bool v1 = true;
    bool v2 = false;
    bool v3 = false;

    bool r1 = v1 || v2 && v3;
    bool r2 = (v1 || v2) && v3;
    bool r3 = v1 || (v2 && v3);

    cout << r1 << endl;
    cout << r2 << endl;
    cout << r3 << endl;

    //결과 
    // 1 0 1 

  ```
********
<div id ="6"></div>

## 이진수
- 2진수에서 10진수로 변환하기 -> 자릿수를 다 곱해서 더한다
- 10진수를 2진수로 변환하기 -> 계속 2로 나눈다. 나머지는 0, 1인데, 몫이 0이 될때까지 2로 나눈 후 역으로 나머지를 적어내면 2진수가 됨
 
  ********
<div id ="7"></div>

## 비트단위 연산자 
 - 낭비되는 메모리를 최소화 하기 위해서 비트 단위로 연산할 수 있게 만든 연산자
 - 비트단위로 연산하면 계산속도가 빠르다
 - 비트연산을 할때는 대부분 unsigned를 사용한다
  
  ### **<<** left shift 
     비트를 왼쪽으로 한칸씩 밀어준다. 숫자가 2배씩 커진다
     2배씩 커지는 연산을 할때 *말고 <<를 쓰는게 훨씬 퍼포먼스가 좋다

  ### **>>** right shift    
     비트를 오른쪽으로 한칸씩 밀어준다. 숫자가 2배씩 작아진다
     2로 나누는 연산을 할때 *나 /말고 >>를 쓰는게 훨씬 퍼포먼스가 좋다

  ### **~**  not
     0과 1을 뒤바꾼다. 10진수에서의 규칙성은 특별히 없다

  ### **&**  and
     각 비트별로 and연산을 한 결과를 2진수로 나타낸다
     각 자리의 두 비트의 값이 같으면 1, 다르면 0이다 

  ### **|**  or
     각 비트별로 or연산을 한 결과를 2진수로 나타낸다
     각 자리의 두 비트중 하나라도 1이면 1, 둘 다 0이면 0이다

  ### **^**  xor
     각 비트별로 xor연산을 한 결과를 2진수로 나타낸다
     각 자리의 두 비트의 값이 서로 다르면 1, 같으면 0이다 


  - cout cin에서의 << >> 과는 다른 의미이다
  - 여기서는 연산자 오버로딩으로 다르게 사용되고 있다
   
  <br>

  - and or xor은 비트마스크 비트플래그 처리에 유용하게 쓰인다
  - and or xor의 결과값은 10진수로 나온다 

  <br>

  - 0b를 앞에 붙이면 2진수로 바로 표현이 가능하다 
    - ex) 0b0110 => 5

******

### bitset 라이브러리 
- bitset을 include하여 사용한다
- `std::bitset<보여줄 비트 수>(정수)` 형태로 사용
- 10진수를 2진수로 바꾸어 보여준다

  ********
<div id ="8"></div>

## 비트마스크, 비트플래그 
- 1byte는 8개의 true false를 표시할 수 있다 = 8bit
- 적은 메모리로 다양한 변수를 처리할 수 있는 것이 비트연산의 장점

### 비트 플래그
  - flag 처리를 위해 비트연산을 사용 
  
  > 예제 코드 
  ``` c++
    const unsigned char opt0 = 1 << 0; // 00000001
    const unsigned char opt1 = 1 << 1; // 00000010
    const unsigned char opt2 = 1 << 2; // 00000100
    const unsigned char opt2 = 1 << 3; // 00001000


    //8개의 아이템 표기를 위해 1byte char를 이용한다
    unsigned char item_flag = 0;

    //특정 option을 추가할 땐 | 연산
    item_flag |= opt1;
    //item_flag = item_flag & opt1;

    //특정 option을 제거할 땐 &와 ~을 이용
    item_flag &= ~opt3;

    //특정 option를 가지고 있는지 체크할 땐 & 연산 
    if (item_flag & opt1)
    {
        //opt1 자리의 값이 1이면 true를 리턴한다
    }

    //option 여러개를 동시에 갖게 할 때는 |로 묶는다
    item_flag |= (opt2 | opt3);

    //|로 파라미터 1개에 여러 옵션을 한꺼번에 적용할 수 있다
    //ex) openGl에서 glClear()등 옵션 설정해줄때


    //복합조건, 특정 option의 유무들을 판별할 때
    if((item_flag & opt2) && !(item_flag & opt1) )
    {
        //option의 상태를 전환할 때는 ^ 연산
        item_flag ^= opt2;
        item_flag ^= opt1;
        //두개를 합치면 item_flag ^= (opt2 | opt1);
    }

  ```

  ### 비트마스크 
  - 특정 비트에서 마스크를 이용하여 일정 부분만 추출해내는 것
  - 특히 16진수로 이루어진 컬러코드에서 (ex #DDA520) rgb값 추출에도 쓴다

> 예제 코드
```c++ 
unsigned int pixel_color = 0xDAA520;
    //0x 를 붙이면 16진수로 표현이 가능하다 

    const unsigned int red_mask = 0xFF0000;
    const unsigned int green_mask = 0x00FF00;
    const unsigned int blue_mask = 0x0000FF;
    //가장 큰 값인 FF를 마스크 값으로 사용 

    cout<< bitset<32>(pixel_color) << endl;

    unsigned char red,green,blue;
    //컬러코드는 16진수로 앞부터 두개씩 red, green, blue 로 처리한다.

    //blue를 추출하기 
    blue = pixel_color & blue_mask;

    green = (pixel_color & green_mask) >> 8;
    //1. green값은 32비트의 중앙쯤 있어서 8비트인 char에 제대로 담기지 않는다
    //2. >>를 이용해 옆으로 8비트 밀어버리고 char로 출력한다

    red = (pixel_color & red_mask) >> 16;
    // green, blue 값을 밀어내야 char 에 담기기 때문에 16비트를 오른쪽으로 민다

    /**
    0xDDA520 => 00000000110110101010010100100000
      
    추출 결과: 
    blue: 00100000  = 32
    green: 10100101  = 165
    red: 11011010  = 218

    **/
```