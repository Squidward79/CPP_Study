# 4장 변수범위와 변수형

## 목차 

[4.1. 각종 변수들](#1)

[4.2 Auto 키워드와 자료형 추론](#2)

[4.3 명시적 형변환과 암시적 형 변환](#3)

[4.4 문자열 std string](#4)

[4.5 열거형 enumerated types](#5)

[4.6 typedef, 자료형의 가명](#6)

[4.7 구조체 struct](#7)

********
<div id="1"></div>

## 전역,정적변수와 내부,외부 연결
  
### static 키워드
- static이 붙은 해당변수는 메모리가 고정된다
- 초기화가 1번만 이루어지고, 이후부터는 선언이 의미가 없다
- 초기화 이후에는 해당 변수는 같은 메모리를 공유한다
- 그래서 반드시 처음 변수 선언 시 초기화가 이루어져야 한다
- 디버깅용도로 많이 사용한다.

### 내부연결과 외부연결
- 각각의 obj파일을 연결하는 것은 Linker가 수행한다
  
    >내부연결(Internal Linkage)
  - 동일 파일 내에서 연결되는 변수들
  - 전역으로 선언된 변수가 다른 함수들에서 접근이 가능한 것
  - static을 붙인 전역변수는 외부 파일에서의 접근은 어렵다
  
  >외부연결(External Linkage)
    - 외부 파일에서 접근이 가능한 연결
    - 다른 파일의 함수 body가 있다면, 현재 파일에서 함수형태를 선언(forward declaration)만 해줘도 컴파일러가 프로젝트 내에서 함수body를 찾아서 호출 할 수 있게 해준다.
    - 이 경우에는 **extern** 키워드가 생략되어 있다 

- **extern** 키워드는, 프로젝트 전체에 걸쳐 바로 사용가능한 전역변수 처럼 작용하도록 만든다. 외부 파일에서도 접근 가능하다

 ---------
<div id="2"></div>

## Auto 키워드와 자료형 추론
  - 자동으로 자료형을 결정
  - 초기화가 되어야 auto를 사용할 수 있다 
  - 함수의 반환형도 auto가 가능하지만, 파라미터에는 auto 불가능
  - 함수 선언부 옆에 -> 를 쓰고 자료형을 쓰면, 리턴타입을 명시하는 셈 (trailing return type)
    - ex) auto add(int x, int y) -> int
  - auto 대신 리턴타입을 써도 되지만, 오버로딩이 많이 있을 경우 보기 편하다

 ---------
<div id="3"></div>

## 명시적 형변환과 암시적 형 변환 
>암시적 형변환
- 더 작은 자료형에 큰 값을 담으면 엉뚱한 값이 담기는 문제가 발생한다
- 작은 형이 감당할 수 있는 값일 경우는 큰 자료형이어도 변환이 된다
- double->float 변환일 때 소수점 정밀도가 떨어질 수 있다
- float -> int 변횐일 경우 소수점은 버려진다
>명시적 형변환
``` 
  static_cast<int>와 같은 형태로 변환한다 
```
- **unsigned가 포함된 연산은 형변환 우선순위 때문에 주의가 필요하다**

 ---------
<div id="4"></div>

## 문자열 std string

- #include<_string_> 이 필요하다

- string은 char[] 과 비슷한데, char[]의 count는 문자 수 + 1 ( 끝에 null이 들어있음) 인데, string의 length는 문자 수 그대로다 

- string 입력받을 때 주의 사항
  - cin 으로 받을 때
    1.   cin은 " " 를 기준으로 끊기 때문에, cin을 연속해서 사용할 경우 버퍼가 비지 않아 원하지 않는 결과가 나올 수 있다
    2.   string을 온전하게 받으려면 **std::getline(내용, 들어갈 변수)** 를 사용하는 것이 좋다
    3.   cin 다음 getline(std::cin, name) 처럼 사용하면 cin의 버퍼가 비지 않아 원하지 않는 결과가 나올 수 있다
    4.   버퍼 내용을 무시하기 위해 std::cin.ignore(32767, '\n')을 사용해, '\n'이 나올 때까지 최대 32767개의 char을 무시한다

- string + string 
  - append 는 더한다는 의미다. 자주 나오는 용어임 
  - '+' 연산자는 미리 정의되어 있어서 그냥 사용할 수 있다

 ---------
<div id="5"></div>

## 열거형 enumerated types

- enum 선언 끝에는 __;을 꼭 붙여야 한다__
- 첫 값의 기본 정수값은 0이며, 그 다음 값부턴 +1된 값으로 적용된다
- 정수를 선언해 주어도 되며, 다음 값부터는 마찬가지로 적용된다
- int로 저장되는 것 처럼 보이나, 실제 동일하게 적용되진 않는다
- int를 enum에 넣으려면 static_cast<_enumName_> 을 사용하여 캐스팅 해야한다

### 영역 제한 열거형 (열거형 클래스)

- ( c++ 11에서 추가 )
- 같은 정수값을 지닌 다른 enum을 비교하면 동일하게 나오는 것을 피하기 위한 방법 
- enum class Name 으로 선언한다
- 해당 enum은 **Name::값** 형식으로 써야 한다 


 ---------
<div id="6"></div>

## 자료형에게 가명 붙이기 

- typedef double distance_t 와 같이 선언한다 
  - **typedef 자료형 변수명** 이며 변수명 끝에 _t를 붙여서 type(자료형) 이라고 명시해주는게 관례
  -  여기서 distance_t는 double과 완전히 같으며 _자료형 자체에 주석을 붙이는 느낌_
  -  비슷한 용도의 변수를 typedef 자료형으로 쓰면 코드의 유지보수에도 큰 도움이 된다
  -  복잡한 구조의 자료형을 줄여 쓰는 형태로도 사용 가능  


 ---------
<div id="7"></div>

## 구조체 struct 

- 구조체의 멤버에 접근제한자를 쓰지 않으면 기본적으로 **public** 이다 
- 멤버함수도 작성 가능하다
- 구조체 선언 후 끝에 ;를 붙이지 않으면 에러가 난다
- '.'은 내부 멤버에 접근 하는 **멤버선택 오퍼레이터** 이다
- 구조체 내에서 초기화해두면 해당 값이 초기 값으로 들어간다

- 데이터 배치에 따라서 구조체의 sizeof 크기가 달라질 수 있다
  - ex) 
    ```c++
    struct example    // 2 + (2) + 4 + 8 = 16byte  
    {
        short id;     //2byte
        int age;      //4byte
        double wage;  //8byte
    }

    sizeof(example) 의 값은 16이 나온다.
    short의 2byte가 배치되는 과정에서 빈칸 2byte가 들어간다
    이 성질을 padding 이라고 부른다  
    ```
